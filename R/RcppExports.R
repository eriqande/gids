# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' rcpp version of g2p.map to see how it fares speedwise
#'
#' Just a reimplementation using Rcpp.  This returns a matrix.  The first column
#' are the phenotype values and the second column are the sexes.
#' @param G the structure giving the genotypes of the indviduals.  Actually a 3-D array indexed by indiv, locus, gene copy
#' @param dims the dimensions of the 3-D array G for internal use.
#' @param bvs matrix of the breeding values, indexed by loci and alleles
#' @param num_loci_t  the number of loci, essentially something to get the mean Z to be 0
#' @param v_e the environmental variance in the phenotype
#' @export
rcpp_g2p_map <- function(G, dims, bvs, num_loci_t, v_e) {
    .Call('gids_rcpp_g2p_map', PACKAGE = 'gids', G, dims, bvs, num_loci_t, v_e)
}

#' rcpp version of function that does recombination and segregation
#'
#' Note that this is hard-wired for diploidy.
#' @param G the structure giving the genotypes of the indviduals.  Actually a 3-D array indexed by indiv, locus, gene copy
#' @param dims the dimensions of the 3-D array G for internal use.
#' @param rf vector of recombination fractions.  There should be one minus the number of loci. The first
#' one corresponds to recombination between the first and the second marker.  These are the probabilities
#' of a recombination between the markers during a meiosis.
#' @return  The return value is a long vector that can be squished into a matrix as appropriate to put it into
#' the genotype struct.
#' @export
rcpp_recombo_segregate <- function(G, dims, rf) {
    .Call('gids_rcpp_recombo_segregate', PACKAGE = 'gids', G, dims, rf)
}

#' simple function to return crossover points from an exponential
#'
#' we could swap this out for something more complicated with varying rates and
#' inversions fairly easily.
#' @param chr_len  the length of the chromosome in base pairs
#' @param rate  the rate of recombination per base pair (like 1/10^6)
#' @export
breakpoints1 <- function(chr_len, rate) {
    .Call('gids_breakpoints1', PACKAGE = 'gids', chr_len, rate)
}

#' rcpp version of function that does recombination and segregation with exponential crossovers
#'
#' In this version, we have to have a position for each locus (an integer less than 2^31) and then we have
#' crossing over points exponentially distributed as a Poisson process.  Mean crossover distance is 10^8 base pairs,
#' but that could be changed so that crossovers happen at a variable rate.   Note that this is hard-wired for diploidy.
#' @param G the structure giving the genotypes of the indviduals.  Actually a 3-D array indexed by indiv, locus, gene copy
#' @param dims the dimensions of the 3-D array G for internal use.
#' @param pos vector of positions of the loci.  This is an integer vector.  Has to be in sorted order (ascending)
#' @param chromo_length total chromoome length in base pairs
#' @return  The return value is a long vector that can be squished into a matrix as appropriate to put it into
#' the genotype struct.
#' @export
rcpp_recombo_segregate_expo <- function(G, dims, pos, chromo_length) {
    .Call('gids_rcpp_recombo_segregate_expo', PACKAGE = 'gids', G, dims, pos, chromo_length)
}

#' dispersal function in rcpp
#'
#' a quick rcpp based implementation because the abind in the R implementation
#' gobbles up a lot of time.  For this you just pass in a vector for pop1 and a vector for
#' pop2 that says where each individual goes.  That way we can do the individual selection
#' outside of this function.
#' @param P1 first pop struct, indexed by indiv, locus, gene copy
#' @param P2 second pop struct
#' @param d1 dim of first pop struct
#' @param d2 dim of second pop struct
#' @param a1 assignments of individuals in pop 1 to either pop 1 or 2
#' @param a2 assignments of individuals in pop 2 to either pop 1 or 2
#' @export
rcpp_dispersal_placement <- function(P1, P2, d1, d2, a1, a2) {
    .Call('gids_rcpp_dispersal_placement', PACKAGE = 'gids', P1, P2, d1, d2, a1, a2)
}

