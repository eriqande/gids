# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Phenotype function from C++
#'
#' A function for the computation of additive phenotypes
#' @param G An object of class \code{"struct"} with the genetic structure of each individual in the population.
#' @param dims A vector with the dimensions of the 3-D array G.
#' @param bvs A matrix with the breeding values, indexed by loci and alleles
#' @param add_loci A vector with the position of additive loci participating in the computation of phenotypes.
#' @param sex_ratio A numerical value defining the sex ratio of populations
#' @param e_v A numerical value defining the environmental variance in the computation of phenotypes.
#' @export
#' @keywords internal
rcpp_g2p_map <- function(G, dims, bvs, add_loci, sex_ratio, e_v) {
    .Call('_glads_rcpp_g2p_map', PACKAGE = 'glads', G, dims, bvs, add_loci, sex_ratio, e_v)
}

#' rcpp version of function that does recombination and segregation
#'
#' Note that this is hard-wired for diploidy.
#' @param G the structure giving the genotypes of the indviduals.  Actually a 3-D array indexed by indiv, locus, gene copy
#' @param dims the dimensions of the 3-D array G for internal use.
#' @param rf vector of recombination fractions.  There should be one minus the number of loci. The first
#' one corresponds to recombination between the first and the second marker.  These are the probabilities
#' of a recombination between the markers during a meiosis.
#' @return  The return value is a long vector that can be squished into a matrix as appropriate to put it into
#' the genotype struct.
#' @export
#' @keywords internal
rcpp_recombo_segregate <- function(G, dims, rf) {
    .Call('_glads_rcpp_recombo_segregate', PACKAGE = 'glads', G, dims, rf)
}

#' simple function to return crossover points from an exponential
#'
#' we could swap this out for something more complicated with varying rates and
#' inversions fairly easily.
#' @param chr_len  the length of the chromosome in base pairs
#' @param rate  the rate of recombination per base pair (like 1/10^6)
#' @export
#' @keywords internal
breakpoints1 <- function(chr_len, rate) {
    .Call('_glads_breakpoints1', PACKAGE = 'glads', chr_len, rate)
}

#' rcpp version of function that does recombination and segregation with exponential crossovers
#'
#' In this version, we have to have a position for each locus (an integer less than 2^31) and then we have
#' crossing over points exponentially distributed as a Poisson process.
#' but that could be changed so that crossovers happen at a variable rate.   Note that this is hard-wired for diploidy.
#' @param G the structure giving the genotypes of the indviduals.  Actually a 3-D array indexed by indiv, locus, gene copy
#' @param dims the dimensions of the 3-D array G for internal use.
#' @param pos vector of positions of the loci.  This is an integer vector.  Has to be in sorted order (ascending)
#' @param chromo_length total chromoome length in base pairs
#' @param cross per base-pair rate of recombination.  For example, 1 cM per megabase equates to 1e-08.
#' @return  The return value is a long vector that can be squished into a matrix as appropriate to put it into
#' the genotype struct.
#' @export
#' @keywords internal
rcpp_recombo_segregate_expo <- function(G, dims, pos, chromo_length, cross) {
    .Call('_glads_rcpp_recombo_segregate_expo', PACKAGE = 'glads', G, dims, pos, chromo_length, cross)
}

#' dispersal function in rcpp
#'
#' a quick rcpp based implementation because the abind in the R implementation
#' gobbles up a lot of time.  For this you just pass in a vector for pop1 and a vector for
#' pop2 that says where each individual goes.  That way we can do the individual selection
#' outside of this function.
#' @param P1 first pop struct, indexed by indiv, locus, gene copy
#' @param P2 second pop struct
#' @param d1 dim of first pop struct
#' @param d2 dim of second pop struct
#' @param a1 assignments of individuals in pop 1 to either pop 1 or 2
#' @param a2 assignments of individuals in pop 2 to either pop 1 or 2
#' @export
#' @keywords internal
rcpp_dispersal_placement <- function(P1, P2, d1, d2, a1, a2) {
    .Call('_glads_rcpp_dispersal_placement', PACKAGE = 'glads', P1, P2, d1, d2, a1, a2)
}

#' read ms-formatted MaCS output into a matrix of haplotypes.
#'
#' This is implemented in Rcpp for speed.  It is designed to read a single replicate coalescent
#' simulation in macs' msformatter format and convert the 0/1's to 1/2's and return in a big integer
#' matrix of haplotypes that can then be put together as desired later. (i.e. different pops and into
#' different diploid individuals)
#' @param Input the path to the mac | msformatter output file to read in. Note that
#' tilde expansion will not occur on this path
#' @export
#' @keywords internal
read_macs_output <- function(Input) {
    .Call('_glads_read_macs_output', PACKAGE = 'glads', Input)
}

